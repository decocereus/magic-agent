use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Execution plan generated by LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Plan {
    pub version: String,
    #[serde(default)]
    pub target: Option<PlanTarget>,
    #[serde(default)]
    pub preconditions: Vec<Precondition>,
    #[serde(default)]
    pub operations: Vec<Operation>,
    #[serde(default)]
    pub error: Option<String>,
    #[serde(default)]
    pub suggestion: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanTarget {
    pub project: Option<String>,
    pub timeline: Option<String>,
}

/// Precondition that must be met before execution
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Precondition {
    ProjectOpen,
    TimelineExists { name: String },
    TimelineActive,
    TrackExists { track_type: String, index: i32 },
    ClipExists { track: i32, index: i32 },
    MediaExists { name: String },
}

/// Operation to execute
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Operation {
    pub op: String,
    #[serde(default)]
    pub params: Value,
}

impl Plan {
    /// Check if plan is an error response
    pub fn is_error(&self) -> bool {
        self.error.is_some()
    }

    /// Validate plan structure
    pub fn validate(&self) -> Result<(), String> {
        if self.version != "1.0" {
            return Err(format!("Unsupported plan version: {}", self.version));
        }

        if self.is_error() {
            return Ok(()); // Error plans are valid
        }

        if self.operations.is_empty() {
            return Err("Plan has no operations".to_string());
        }

        // Validate each operation
        for (i, op) in self.operations.iter().enumerate() {
            if !Self::is_valid_operation(&op.op) {
                return Err(format!("Unknown operation '{}' at index {}", op.op, i));
            }
        }

        Ok(())
    }

    fn is_valid_operation(op: &str) -> bool {
        matches!(
            op,
            // Media
            "import_media"
                | "append_to_timeline"
                | "create_timeline"
                // Clip Properties
                | "set_clip_property"
                | "set_clip_enabled"
                | "set_clip_color"
                // Markers
                | "add_marker"
                | "delete_marker"
                // Tracks
                | "add_track"
                | "set_track_name"
                | "enable_track"
                | "lock_track"
                | "delete_track"
                // Render
                | "add_render_job"
                | "start_render"
                | "set_render_settings"
                | "get_render_formats"
                | "get_render_codecs"
                | "set_render_format_and_codec"
                | "get_render_presets"
                | "load_render_preset"
                | "save_render_preset"
                | "delete_render_preset"
                | "get_render_jobs"
                | "delete_render_job"
                | "delete_all_render_jobs"
                | "get_render_job_status"
                // Timeline
                | "set_timeline"
                | "duplicate_timeline"
                | "export_timeline"
                | "import_timeline_from_file"
                // Fusion & Compositions
                | "insert_fusion_composition"
                | "create_fusion_clip"
                | "add_fusion_comp_to_clip"
                | "create_compound_clip"
                // Generators & Titles
                | "insert_generator"
                | "insert_title"
                // Text+ Operations
                | "set_text_content"
                | "set_text_style"
                | "get_text_properties"
                | "add_text_to_timeline"
                // AI/Processing
                | "stabilize_clip"
                | "smart_reframe"
                | "create_magic_mask"
                | "detect_scene_cuts"
                // Clip Management
                | "delete_clips"
                | "set_clips_linked"
                // Navigation
                | "set_current_timecode"
                | "get_current_timecode"
                | "open_page"
                | "get_current_page"
                // Audio
                | "create_subtitles_from_audio"
                | "detect_beats"
                // Stills & Gallery
                | "grab_still"
                | "export_still"
                | "apply_grade_from_drx"
                | "get_gallery_albums"
                // Color Grading
                | "apply_lut"
                | "get_lut"
                | "set_cdl"
                | "copy_grades"
                | "reset_grades"
                | "add_color_version"
                | "load_color_version"
                | "get_color_versions"
                | "delete_color_version"
                // Color Groups
                | "create_color_group"
                | "get_color_groups"
                | "assign_to_color_group"
                | "remove_from_color_group"
                | "delete_color_group"
                // Media Pool
                | "create_media_pool_folder"
                | "set_current_media_pool_folder"
                | "move_media_pool_clips"
                | "delete_media_pool_clips"
                | "delete_media_pool_folders"
                | "set_clip_metadata"
                | "get_clip_metadata"
                | "relink_clips"
                // Flags
                | "add_flag"
                | "get_flags"
                | "clear_flags"
                // Takes
                | "add_take"
                | "select_take"
                | "get_takes"
                | "finalize_take"
                | "delete_take"
                // Project Settings
                | "save_project"
                | "export_project"
                | "get_project_setting"
                | "set_project_setting"
                | "get_timeline_setting"
                | "set_timeline_setting"
                // Keyframe Mode
                | "set_keyframe_mode"
                | "get_keyframe_mode"
                // Cache
                | "set_clip_cache_mode"
                | "get_clip_cache_mode"
                | "refresh_lut_list"
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_plan() {
        let json = r#"{
            "version": "1.0",
            "target": {
                "project": "content",
                "timeline": "Timeline 1"
            },
            "preconditions": [
                { "type": "project_open" },
                { "type": "timeline_active" }
            ],
            "operations": [
                {
                    "op": "set_clip_property",
                    "params": {
                        "selector": { "track": 1, "all": true },
                        "properties": { "Opacity": 50.0 }
                    }
                }
            ]
        }"#;

        let plan: Plan = serde_json::from_str(json).unwrap();
        assert_eq!(plan.version, "1.0");
        assert_eq!(plan.operations.len(), 1);
        assert!(plan.validate().is_ok());
    }

    #[test]
    fn test_parse_error_plan() {
        let json = r#"{
            "version": "1.0",
            "error": "Cannot move clips on timeline",
            "suggestion": "Manually drag clips in Resolve UI"
        }"#;

        let plan: Plan = serde_json::from_str(json).unwrap();
        assert!(plan.is_error());
        assert!(plan.validate().is_ok());
    }
}
