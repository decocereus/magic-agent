use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Execution plan generated by LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Plan {
    pub version: String,
    #[serde(default)]
    pub target: Option<PlanTarget>,
    #[serde(default)]
    pub preconditions: Vec<Precondition>,
    #[serde(default)]
    pub operations: Vec<Operation>,
    #[serde(default)]
    pub error: Option<String>,
    #[serde(default)]
    pub suggestion: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanTarget {
    pub project: Option<String>,
    pub timeline: Option<String>,
}

/// Precondition that must be met before execution
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Precondition {
    ProjectOpen,
    TimelineExists { name: String },
    TimelineActive,
    TrackExists { track_type: String, index: i32 },
    ClipExists { track: i32, index: i32 },
    MediaExists { name: String },
}

/// Operation to execute
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Operation {
    pub op: String,
    #[serde(default)]
    pub params: Value,
}

impl Plan {
    /// Check if plan is an error response
    pub fn is_error(&self) -> bool {
        self.error.is_some()
    }

    /// Validate plan structure
    pub fn validate(&self) -> Result<(), String> {
        if self.version != "1.0" {
            return Err(format!("Unsupported plan version: {}", self.version));
        }

        if self.is_error() {
            return Ok(()); // Error plans are valid
        }

        if self.operations.is_empty() {
            return Err("Plan has no operations".to_string());
        }

        // Validate each operation
        for (i, op) in self.operations.iter().enumerate() {
            if !Self::is_valid_operation(&op.op) {
                return Err(format!("Unknown operation '{}' at index {}", op.op, i));
            }
        }

        Ok(())
    }

    fn is_valid_operation(op: &str) -> bool {
        matches!(
            op,
            "import_media"
                | "append_to_timeline"
                | "create_timeline"
                | "set_clip_property"
                | "add_marker"
                | "delete_marker"
                | "add_track"
                | "set_track_name"
                | "enable_track"
                | "lock_track"
                | "add_render_job"
                | "start_render"
                | "set_timeline"
                | "duplicate_timeline"
                | "export_timeline"
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_plan() {
        let json = r#"{
            "version": "1.0",
            "target": {
                "project": "content",
                "timeline": "Timeline 1"
            },
            "preconditions": [
                { "type": "project_open" },
                { "type": "timeline_active" }
            ],
            "operations": [
                {
                    "op": "set_clip_property",
                    "params": {
                        "selector": { "track": 1, "all": true },
                        "properties": { "Opacity": 50.0 }
                    }
                }
            ]
        }"#;

        let plan: Plan = serde_json::from_str(json).unwrap();
        assert_eq!(plan.version, "1.0");
        assert_eq!(plan.operations.len(), 1);
        assert!(plan.validate().is_ok());
    }

    #[test]
    fn test_parse_error_plan() {
        let json = r#"{
            "version": "1.0",
            "error": "Cannot move clips on timeline",
            "suggestion": "Manually drag clips in Resolve UI"
        }"#;

        let plan: Plan = serde_json::from_str(json).unwrap();
        assert!(plan.is_error());
        assert!(plan.validate().is_ok());
    }
}
